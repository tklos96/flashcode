<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FLASH5 Test: fortran/FLASH5/source/Simulation/Simulation_defineDomain.F90 File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FLASH5 Test
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_9d95adc37effe2d0447790667f945c24.html">fortran</a></li><li class="navelem"><a class="el" href="dir_aaca5e2157f58805ddf087a6c1d4d986.html">FLASH5</a></li><li class="navelem"><a class="el" href="dir_d9542af6519f0ca27bc6117ad523d5c6.html">source</a></li><li class="navelem"><a class="el" href="dir_eb3bc892adc6d650c124d9cdefebff96.html">Simulation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">Simulation_defineDomain.F90 File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a1f55726d20309830aba3f597173292fe"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_simulation__define_domain_8_f90.html#a1f55726d20309830aba3f597173292fe">simulation_definedomain</a> (initialDomain, boundaries, nblks)</td></tr>
<tr class="separator:a1f55726d20309830aba3f597173292fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="a1f55726d20309830aba3f597173292fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f55726d20309830aba3f597173292fe">&#9670;&nbsp;</a></span>simulation_definedomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine simulation_definedomain </td>
          <td>(</td>
          <td class="paramtype">logical, dimension(nblks(iaxis),nblks(jaxis),nblks(kaxis)), intent(out)&#160;</td>
          <td class="paramname"><em>initialDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(2*mdim,nblks(iaxis),nblks(jaxis),nblks(kaxis)), intent(out)&#160;</td>
          <td class="paramname"><em>boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(mdim), intent(in)&#160;</td>
          <td class="paramname"><em>nblks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p></p>
<p>call Simulation_defineDomain(logical(:,:,:),OUT :: initialDomain, integer(:,:,:,:),OUT :: boundaries, integer(MDIM), IN :: nblks)</p>
<p></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nblks</td><td>Integer Array of size MDIM, containing the number of blocks along each dimension </td></tr>
    <tr><td class="paramname">initialDomain</td><td>Logical 3D array of size nblks(IAXIS),nblks(JAXIS), nblks(KAXIS) If the block i,j,k is in the domain then on return initialDomain(i,j,k)=.true. otherwise .false. </td></tr>
    <tr><td class="paramname">boundaries</td><td>integer array of size 2*MDIM,nblks(IAXIS),nblks(JAXIS), nblks(KAXIS) If the block i,j,k is in the domain, the values in this array have no meaning. If the block is not in the domain, but is adjacent to one or more blocks that are in the domain, then the entries corresponding to the common faces get initialized with appropriate boundary values. Constants for boundary conditions are defined in "constants.h". Any boundary conditions in the allowed </td></tr>
    <tr><td class="paramname">range</td><td>of numerical values 50.. are recognized by the GridBoundaryConditions implementation, with the exception that PERIODIC is not allowed here. Example Consider a 2D domain with the following shape with reflecting boundaries * * * * * * * * * * * * * * * * * * * * It can be divided into 4x4 blocks as follows * T * T * T * F * * * * * * * T * T * T * T * * * * * * * T * T * T * T * * * * * * * F * T * T * T * * * * * * This domain can be initialize through the following sequence of instructions !! This implementation is meant to be used with NDIM==2. initialDomain = .true. boundaries = NOT_BOUNDARY initialDomain(1,1,1)=.false. boundaries(IHI_FACE,1,1,1)=REFLECTING boundaries(JHI_FACE,1,1,1)=REFLECTING initialDomain(4,4)=.false. boundaries(ILO_FACE,4,4,1)=REFLECTING boundaries(JLO_FACE,4,4,1)=REFLECTING</td></tr>
  </table>
  </dd>
</dl>
<p>NAME</p>
<p>Simulation_defineDomain</p>
<p>DESCRIPTION</p>
<p>This routine provides a hook for defining domains that are not shaped like boxes. The stub implementation returns a domain that is shaped like a box. The users wishing to define a non-box like domain should have a custom implementation of this routine in their Simulations directory. Only domains that can be represented as a union of non-overlapping same-size boxes place on an equally-space grid can represented.</p>
<p>This feature is currently only available with PARAMESH. When building FLASH with UG, any Simulation_defineDomain is ignored.</p>
<p>Conceptually, one defines an irregular domain by placing obstacle blocks in a regular box-shaped domain. These obstacle blocks all have the same physical size, and the original domain size must be a multiple of this size in each dimesion. Obstacle may touch the outer boundaries and each other, and can be combined to form walls etc.</p>
<p>To use this feature: 1) Set up a regular domain as usual. Use the nblockx, nblocky, and nblockz runtime parameters to divide the domain equally into a grid of nblockx*nblocky*nblockz original blocks. 2) Provide an implementation of Simulation_defineDomain that marks some of these original blocks with obstacles. Only the parts of the original domain that are not so marked will end up being in the physical domain. PARAMESH will use the blocks that remain in the domain as root blocks (with refinement level 1) and may adaptively refine (but not combine) them as usual.</p>
<p>To implement Simulation_defineDomain: For each block that belongs in the domain the corresponding entry in the output array initialDomain is set true, and the corresponding entries for all faces in the boundaries array are set to "NOT_BOUNDARY". For the blocks that do not belong in the domain, the corresponding initialDomain entries are set false. The boundaries entries on faces that are adjacent to physical boundaries or to other blocks not in the domain are redundant. However, those boundaries entries that correspond to faces adjacent to the valid blocks in the domain must be given appropriate boundary values. The example included illustrates how to define a domain.</p>
<p>This routine will be called with nblks set to the values given by the paramesh runtime parameters nblockx, nblocky, and nblockz, and the initialDomain and boundaries arrays will be dimensioned accordingly. That is, the boundaries set by this routine apply to blocks at refinement level 1. Any additional refinement levels are generated only after this routine returns.</p>
<p>NOTES</p>
<p>To use any Simulation_defineDomain implementation that actually removes blocks with Paramesh 4, it is currently necessary to increase the value of the constant NBOUNDARIES. This preprocessor symbol is used by Paramesh 4 to dimension certain arrays that store information on boundary blocks. The value of NBOUNDARIES should be set to 2*NDIM + (number of blocks for which this routine returns false). This is most conveniently done with a PPDEFINE in a Config file before setup. See the SodStep simulation as an example. FLASH will abort if Simulation_defineDomain is used and NBOUNDARIES is too low.</p>
<p>For users' convenience, the constants defining the low and high faces along the dimensions are defined in "constants.h". They can be used to specify the first index of the boundaries array. They are {I,J,K}LO_FACE and {I,J,K}HI_FACE, respectively.</p>
<p>Constants for boundary conditions like REFLECTING and OUTFLOW are defined in "constants.h" as well. The most common of them correspond to recognized values of the {xyz}{lr}_boundary_type runtime parameters.</p>
<p>This routine is only meaningful (and will only be called) when an AMR Grid implementation is used.</p>
<p>Particles have not been tested in combination with arbitrary boundaries. Particles (active or passive) should not be used in irregular domain, at least not if there is any chance that a particle will run into an obstacle block. The behavior of particles at obstacle boundaries should be cinsidered as undefined. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
